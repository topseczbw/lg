# 简答题

<!-- TOC -->

- [js异步编程](#js异步编程)
- [EventLoop（事件循环） 和 消息队列](#eventloop事件循环-和-消息队列)
  - [事件循环](#事件循环)
  - [消息队列](#消息队列)
- [宏任务和微任务](#宏任务和微任务)
  - [产生宏任务方式](#产生宏任务方式)
  - [产生微任务方式](#产生微任务方式)

<!-- /TOC -->

## js异步编程

js设计的初衷是处理用户在浏览器中的交互操作，即操作dom
如果同一个时间，存在两个操作处理同一个dom元素，浏览器是无法判断执行哪个操作的，所以执行js的线程被设计为单线程，但同时又引发了另外一个问题，当代码中有较复杂的计算需要消耗较长的时间时，js代码的执行就会被阻塞

所以出现了js异步编程的方式，当代码执行到异步相关逻辑时，如setTimeout、ajax。代码会继续向下执行，不会被阻塞，传一个callback给异步代码，像是在告诉代码：我继续往下执行了，不等你了，等你setTimeout走完，或者ajax请求到数据之后，执行我给你回调函数就好

如果没有异步模式，js语言就无法同时处理大量耗时任务

异步代码执行顺序不好理解

## EventLoop（事件循环） 和 消息队列

### 事件循环

EventLoop 是执行js事件（用户事件、非用户事件）执行的策略，可以理解为执行任务的一个循环，大致顺序如下：

- 取一个宏任务（script标签中的代码也是一个宏任务）放入Callstack(调用栈)中执行
- 当遇到宏任务时，将任务放入宏任务队列
- 当遇到微任务时，将任务放入微任务队列
- 当调用栈中的代码执行完毕后，清空微任务队列，如果微任务中还有微任务，也会在本轮中同时执行，然后执行必要的渲染和绘制操作
- 从宏任务队列中，取出第一个宏任务执行，如此循环往返
- .....

### 消息队列

消息队列相当于js待办的任务列表，当调用栈中任务执行完毕后，会从消息队列中取一个任务放入调用栈去执行

## 宏任务和微任务

宏任务和微任务可以理解为异步任务的两种形式，两者区别是执行的时机不同

### 产生宏任务方式

1. setTimeout
2. setInterval
3. setImmediate 仅在IE和node中支持
4. 注册事件

### 产生微任务方式

1. Promise中的then
2. queueMicroTask
3. MutationObserver 监听DOM元素

![作业](2020-09-12-16-07-22.png)
